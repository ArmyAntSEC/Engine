import java.awt.*;
import java.awt.event.*;
import java.applet.*;
import java.net.*;

/**
* The Buttons class handles the input from the user. It contains a variety of buttons and 
* checkboxes that let the user start and stop the simulation, as well as move the viewpoint. 
* The user can further change certain aspects of the rendering, as well as choose to show 
* the help-files and documentation in a popup window.
*
*@author Daniel Armyr
*/

public class Buttons extends Panel implements ActionListener, AdjustmentListener, ItemListener
{
    /**
     * Pause button
     */   
    public Checkbox pause;
    /**
	* Strafe or move the camera.
	*/   
    public Checkbox strafe;
    /**
	* Orbit/Rotate the camera.
	*/   
    public Checkbox rotate;
    /**
	* Track a certain particle.
	*/  
    public Checkbox track;
    /**
	* Screw the camera.
	*/ 
    public Checkbox screw;
    /**
	* Show kinematics.
	*/ 
    public Checkbox acc;
    /**
	* The group of buttons that define camera-motion modes.
	*/ 
    public CheckboxGroup modeButtons;
    /**
     * Displays the help.
     */ 
    public Button help;

    /**
     *Restarts the applet
     */
    public Button restart;
    /**
     * Adjusts the gravitational constant.
     */
    public Scrollbar gravity;

    private View view;
    private Clock clock;
    private Scene scene;
    private Engine engine;
    private AppletContext context;
    private URL helpURL;
	
    /** 
 	* Constructs a <code>Buttons</code> object. 
 	* @param v The view to be controlled by this set of buttons.
 	* @param s The thread that the buttons should control.
 	* @param c The scene that the buttons should pass their input to.
 	* @param con The current AppletContext. It will be used to display the help
 	* @param helpU The complete URL to the help files.
 	*/
    public Buttons ( View v, Clock s, Scene c, Engine e, AppletContext con, URL helpU )
    {
	view = v;
	clock = s;
	scene = c;
	engine = e;
	context = con;
	helpURL = helpU;

	modeButtons = new CheckboxGroup();

	pause = new Checkbox ( "Pause" );
	pause.addItemListener( this );
	pause.setBounds ( 500, 0, 100, 50 );
	
	acc = new Checkbox ( "Kinematics" );
	acc.addItemListener ( this );
	acc.setBounds ( 600, 0, 100, 50 );

	strafe = new Checkbox ( "Move", modeButtons, false );
	strafe.addItemListener ( this );
	strafe.setBounds ( 500, 50, 100, 50 );

	rotate = new Checkbox ( "Orbit", modeButtons, false );
	rotate.addItemListener ( this );
	rotate.setBounds ( 600, 50, 100, 50 );

	screw = new Checkbox ( "Screw", modeButtons, false );
	screw.addItemListener ( this );
	screw.setBounds ( 500, 100, 100, 50 );
	
	track = new Checkbox ( "Track", modeButtons, false );
	track.addItemListener ( this );
	track.setBounds ( 600, 100, 100, 50 );
	
	help = new Button ( "Help" );
	help.addActionListener ( this );
	help.setBounds ( 500, 150, 100, 50 );

	restart = new Button ( "Restart" );
	restart.addActionListener ( this );
	restart.setBounds ( 600, 150, 100, 50 );

	gravity = new Scrollbar ( Scrollbar.VERTICAL, 50, 5, 0, 105 );
	gravity.addAdjustmentListener ( this );
	gravity.setBounds ( 700, 0, 20, 500 );
	
	scene.setGrav ( 50 );
    }
    
    /**
    * Handles all the button pressings. In the current implementation only the help is a button. 
    * If the Help button is pressed, the browser will display the help files in a separate window.
    */
    public void actionPerformed ( ActionEvent e )
    {
	if ( e.getSource() == help ) {
	    try {
		context.showDocument( helpURL , "_blank" );
	    } catch( Exception ex ) {
		//Can't be bothered
	    }
	} else if ( e.getSource() == restart ) {
	    engine.init();
	}

    }                                   
    
    /**
 	* Informs the scene that the gravity has been changed.
 	*/ 
    public void adjustmentValueChanged ( AdjustmentEvent e ) {
    
    	if ( e.getSource() == gravity ) {   
	    scene.setGrav ( e.getValue() );		    
    	}
    }
    
    /**
  	* Handles the checkbox events. It will inform the View how to interpret mouse events, 
  	* tells threads to start and stop as well as telling the scene what rendering options to use.
  	*/
    public void itemStateChanged ( ItemEvent e )
    {
	if ( e.getSource() == acc ) {
	    scene.toggleKin();
	    //modeButtons.setSelectedCheckbox ( null ); //Does not appear necessary.
	} else if ( e.getSource() == pause ) {
	    if ( pause.getState() ) {  //Took away an == true
		clock.setActive ( false );
		context.showStatus( "Simulation paused" );
		//view.setCursor ( new Cursor ( Cursor.WAIT_CURSOR ) );
	    } else if ( !pause.getState() ) { //took away an == false
		clock.setActive ( true );
		context.showStatus( "Simulation resumed" );	       
		//view.setCursor ( new Cursor ( Cursor.DEFAULT_CURSOR ) );
	    }
	    //modeButtons.setSelectedCheckbox ( null ); //Does not appear necessary.
	} else if ( e.getSource() == track ) {
	    view.setMouseMode ( "Track" );
	    context.showStatus( "Tracking Mode" );
	    view.setCursor ( new Cursor ( Cursor.CROSSHAIR_CURSOR ) );
	} else if ( e.getSource() == strafe ) {
	    view.setMouseMode ( "Strafe" );
	    context.showStatus( "Move Mode" );
	    view.setCursor ( new Cursor ( Cursor.HAND_CURSOR ) );
	} else if ( e.getSource() == rotate ) {
	    view.setMouseMode ( "Rotate" );
	    context.showStatus( "Orbit Mode" );
	    view.setCursor ( new Cursor ( Cursor.MOVE_CURSOR ) );
	} else if ( e.getSource() == screw ) {
	    view.setMouseMode ( "Screw" );
	    context.showStatus( "Screw Mode" );
	    view.setCursor ( new Cursor ( Cursor.NW_RESIZE_CURSOR ) );
	} else {
	    context.showStatus ( "Engine/actionPerformed: Unhandled button event." );
	}                                      	
    }

}



/**
* This is the super-class for all cameras. It holds some general 
* methods like translating, rotating, and a generalized constructor. 
*/
public abstract class Camera implements Location
{
  	/** The cameras current position */
    protected Vector3 pos; 
    /** A vector defining the right limit of the view-port */
    protected Vector3 right;
    /** A vector defining the upper limit of the view-port */ 
    protected Vector3 up;
    /** A vector pointing in the view direction of the camera */ 
    protected Vector3 dir;
    /** A 2d vector defining half the width and height of the view-port. Used for calculations. */ 
    protected Vector3 size;                                                                      
    
    private Location frame; 
    private Vector3 frameVector; 

    /**   
     * Creates an instance of Camera. 
     * @param pos The initial position of the camera.
     * @param right A vector defining the right limit of the view-port  
     * @param up A vector defining the upper limit of the view-port 
     */
    public Camera ( Vector3 pos, Vector3 right, Vector3 up )
    {
	this.pos = new Vector3();
	this.right = new Vector3();
	this.up = new Vector3();
	this.size = new Vector3();

	this.pos.cp( pos );

	this.right.cp( right );
	this.right = this.right.unit();

	this.up.cp( up );
	this.up = this.up.unit();

	dir = up.cross ( right );
	dir = dir.unit();

	size.x = right.length();
	size.y = up.length();

    }
	/**
	* Rotates the camera around in local space. The system uses 
	* openGL standard with x being the right axel, y being the up axel, and
	* z being the axel into the screen.
	*/
    public void rot( double x, double y, double z )
    {   
    
	up.rotA( x, dir );
	right.rotA( x, dir );
	
	up.rotA( -y, right );
	dir.rotA( -y, right );

	right.rotA( -z, up );
	dir.rotA( -z, up );
	
    }
   
   	/**
	Moves the camera in local space. The system uses 
	* openGL standard with x being the right axel, y being the up axel, and
	* z being the axel into the screen. 
	*/
    public void strafe ( double x, double y, double z )
    {
	//System.out.println ( x + " " + y + " " + z );
	pos = pos.add ( right.mult( x ) ); 
	pos = pos.add ( up.mult( y ) ); 
	pos = pos.add ( dir.mult( z ) ); 

	frameVector = frameVector.add ( right.mult( x ) ); 
	frameVector = frameVector.add ( up.mult( y ) ); 
	frameVector = frameVector.add ( dir.mult( z ) ); 

    }
 
    /** 
     * Orbits the camera around the currently tracked object. Initially, the camera is 
     * hooked to the dummy at the origin, which means it will rotate around the origin.
     * The system uses openGL standard with x being the right axel, y being the up axel, and
     * z being the axel into the screen.
     */
    public void orbit( double x, double y, double z )
    {
	Vector3 oldFrame = new Vector3( frameVector );
	
	double s = 3.14;

	up.rotA( x, dir );
	right.rotA( x, dir );
	frameVector.rotA( x, dir );
	
	up.rotA( -y, right );
	dir.rotA( -y, right );
	frameVector.rotA( -y, right );

	right.rotA( -z, up );
	dir.rotA( -z, up );
	frameVector.rotA( -z, up );
    }

    /**
     *Rolls the camera around current view axel. 
     */
    public void roll ( double a )
    {
	Vector3 oldFrame = new Vector3( frameVector );

	up.rotA( a, dir );
	right.rotA( a, dir );
	frameVector.rotA( a, dir );
    }
    
    /** 
    * A wrapper function for <code>Vector3 project ( Vector3 p3 )</code>.
    */ 
    public Vector3 project ( double x, double y, double z )
    {
	return project ( new Vector3 ( x, y, z ) );
    }
    
    /** 
     * Projects a point in 3-space onto the view-plane of the camera. It is up 
     * to each sub class how to do this. The value returned should be scaled 
     * relative to the values in size. The camera also has the alternative 
     * to return null which will signal the point will not be drawn. 
     * This should include points behind the camera, or other points that
     * return coordinates on-screen but should not be drawn.
     * @param p3 A point in 3-space to be projected.
     */
    public abstract Vector3 project ( Vector3 p3 );  
    
    /**
     * This method queries if sPoint in view-plane coordinates corresponds to a line through oPoint
     * in 3-space. An error smaller than rad will be tolerated. This is used for selection and 
     * querying.
     * @param sPoint A point on the view-plane.   
     * @param oPoint A point in 3-space.
     * @param rad The tolerance.
     * @return true if the two points correspond.
     */
    public abstract boolean collDetect ( Vector3 sPoint, Vector3 oPoint, double rad );
    
   	/** 
    * Returns the cameras current position 
    * @return The cameras position. 
    */
    public Vector3 getPos()
    {
	return pos;
    } 
    
    /** Moves the camera to any position in space. */
    public void setPos( Vector3 p )
    {
	pos.cp(p);
    }
    
    /**
	* Tells the camera to begin tracking an object.
	* @param o The <code>Location</code> to track.
	*/
    public void initTrack ( Location o )
    {
		frame = o;
		frameVector = pos.sub ( o.getPos() );
    }
   
   	/**
   	* Tell the camera to move a distance corresponding to the distance the tracked object 
   	* has moved, in the same direction.
   	*/
    public void doTrack ()
    {
	if ( frame != null && frameVector != null ) {
	    pos = frame.getPos().add ( frameVector );
	} 
    } 
    
    /**
    * Find what object is being tracked.
    * @return The object being tracked.
    */
    public Location getTrack()
    { 
	return frame;
    } 
    
    /**
    * Returns a string describing the current state of the camera. Mostly for debugging.
    * @return A short status report from the camera.
    */
    public String toString()
    {
	return "Pos: " + pos + " Right: " + right + " Up: " + up + " size: " + size;
    }
}




/**
* This little class keeps track of the physics, making sure objects 
* are moved around in time. Nothing unusual about it.
*/
public class Clock extends Thread
{
    
    private Scene scene; //The scene controlled by this thread
    //private int timeLeft;
    private int framePeriod; //Time between frames
    private boolean active = true; //If thread should run or not.

  	/**
    * Constructs a new clock.
    * @param fp The time in milliseconds to wait between each frame.
    * @param s The scene object to be taken care of.
    */	
    public Clock ( int fp, Scene s )
    {
	framePeriod = fp;
	scene = s;
    }

    /** 
     * Sets the state of this thread. It can either be active, 'true', and will 
     * then execute the scene's runFunc(), or inactive, 'false', and wont.<P>
     * This function has been implemented since the deprecated <code>stop()</code> and <code>resume()</code>
     * quite consistently hang not only the Java machine, but the whole computer.
     * <code>wait()</code> and <code>notify()</code> have been suggested as alternatives, but I haven't found any 
     * suitable documentation for those functions.
     * @param state To run or not to run.
     */
    public void setActive ( boolean state )
    {
	active = state;
    }

    /** 
     * First waits a moment, then calls the scenes runFunc function.
     */
    public void run ()
    {
	while ( true ) {
	    try {
		Thread.sleep( framePeriod );
	    }
	    catch ( InterruptedException e ) {}
	    
	    if ( active ) {
		scene.runFunc( );
	    }
	}
    }
}

import java.awt.*;
/**
* This exception is thrown whenever any two particles collide. In it's constructor it 
* automatically calculates the new object which is created, conserving mass and momentum. 
*/
public class CollisionEvent extends Throwable
{ 
	/** The first object in the collision */
    public Part part1;
    /** The second object in the collision */
    public Part part2;
    /** The object resulting from the merger of the above two. */
    public Part result;
    /** The index of the second object in the collision. Used to remove the object from the scene. */
    public int index2;

    /**
	* Simple constructor. Not so simple code inside.....
	* @param p1 Particle 1
	* @param p2 particle 2
	* @param i The index of the second particle. Used for removal.
	*/
    public CollisionEvent ( Part p1, Part p2, int i )
    {
	part1 = p1; //Store some references
	part2 = p2;
	index2 = i; 

	Vector3 moment1 = p1.getVel().mult ( p1.getMass() ); //Calculate the individual moments.
	Vector3 moment2 = p2.getVel().mult ( p2.getMass() );

	Vector3 moment = moment1.add ( moment2 ); //Add them

	Vector3 mPos1 = p1.getPos().mult( p1.getMass() ); //Find the centre of mass
	Vector3 mPos2 = p2.getPos().mult( p2.getMass() );

	double mass = p1.getMass() + p2.getMass(); //Find the total mass

	Vector3 mPos = mPos1.add ( mPos2 ).div ( mass ); //Where to place new object?
	
	Vector3 v = moment.div ( mass ); //What velocity to give it?
	

	result = new Part ( part1.getPos(), mass ); //Make the result
	result.setVel( v ); //Give it a speed
	result.activate(); //Get it moving

    }
}
    

/** 
* A nice location that sits still in the universe. 
* Handy for hooking camera to so they don't float around too much.
*/
public class Dummy implements Location
{
    private Vector3 pos;

	/** Creates a dummy in the prescribed position */
    public Dummy( Vector3 p )
    {
	pos = p;
    }
    
    /** Creates a dummy at the origin */    
    public Dummy ()
    {
	this( new Vector3( 0, 0, 0 ) );
    }
    
    /** 
	* Returns the position of the dummy. 
	* @return The dummies position.
	*/
    public Vector3 getPos ( )
    {
	return pos;
    }
    
    /** 
    * Make sure the dummy can present itself. 
    * @return An empty string. Dummies should never admit their existence. 
    */
    public String toString()
    {
	return "";
    }
}
import java.awt.*;
import java.applet.*;
import java.math.*;
import java.util.*;
import java.awt.event.*;
import java.applet.*;
import java.net.*;

//Not made to be inherited, in case someone tries....
//This applet is made to run in a 500*720 window for the moment. Other sizes will be supported later.
//This is the main control class. It places the different components, and makes sure that all 
//components that need get info about each other.
//WARNING: Appletviewer ignores showDocument() method. This program must be run in a browser that supports all of java.

//Asse request: Make custom cursors for the move, rotate, track etc. Look at Toolkit.createCustomCursor(), and Component.setCursor().

//Good idea: Program should pop up a window asking how many particles, average mass and so on. 

/**
* This is the main control class. It places the different components, and makes sure that all 
* components that need get info about each other. Otherwise there isn't much special about it. 
* All the magic is handled by other classes.
* This applet is made to run in a 500*720 window for the moment. 
* NOTE: Appletviewer ignores showDocument() method. This program must be run in a browser that 
* supports all of java.
* <P>
* Warning!!!<BR>
* This software is not designed or intended for use in on-line control of<BR>
* aircraft, air traffic, aircraft navigation or aircraft communications; or in<BR>
* the design, construction, operation or maintenance of any nuclear<BR>
* facility. Licensee represents and warrants that it will not use or<BR>
* redistribute the Software for such purposes.<BR>
*/
public final class Engine extends Applet 
{

    private Clock clock; //Handles physical time
    private Framer framer; //Handles frame drawing
    
    private int framePeriod = 50; //ms between frames

    private WinDesc w; //Defines the window. It includes width, eight and a graphics object. Allows all objects to draw themselves.
    private Scene scene; //The main scene. Works as a host for individual objects.
    private View view; //The display window. Defined by win-desc. Works closely with Scene
    private Info info; //A small panel that shows info about stuff-
    private Info help; //A small panel that shows help.
    private Image buffer; //Back buffer.
    private Buttons buttons; //A panel of buttons. Handles almost all input.
  
  	/**
    * This function starts up the whole thing, allocating memory, 
    * starting threads, linking objects, the whole thing. Nothing 
    * special, just a miracle of bureaucracy.
    */
    public void init()
    {
	resize ( 720, 500 ); //In case someone tries to mess with the size.

	AppletContext app = getAppletContext(); //Find out some stuff about our surroundings.
	app.showStatus( "Begin Initializing Applet" ); //Talk to the user.
	
	w = new WinDesc ( 500, 500 ); //Sets the current size.
	scene = new Solar( ); //Make the main scene.
	buffer = createImage ( w.w, w.h ); //Create secondary buffer
	info = new Info( null ); //Make an info panel
	help = new Info ( "Instructions:\n\n" +
			  "1)Pause: Pauses and resumes the simulation.\n\n" +
			  "2)Show Kinematics: Displays each objects velocity and acceleration in the view-port.\n\n" +
			  "3)Move: Click and drag in the view-port to move the camera.\n\n" +
			  "4)Orbit: Click and drag in the view-port to orbit the camera around the currently tracked object.\n\n" +
			  "5)Screw: Click and drag in the view-port to roll and dolly the camera.\n\n" +
			  "6)Track: Clicking allows you to select any object. The camera will track the " +
			  "selected object, fixing it in the view-port. Allows you to see the" + 
			  "simulation from any objects perspective." );

	view = new View( scene, w, buffer, info ); //Make a view-port.

	//Make and start a separate thread to remodel the window.
	clock = new Clock ( framePeriod, scene );  
	
	//Make and start a separate thread to repaint the window.
	framer = new Framer ( framePeriod, this );

	try {
	    URL helpURL = new URL ( getCodeBase() + "help.html" ); //URL to the help
	    buttons = new Buttons ( view, clock, scene, this, app, helpURL ); //Make an input panel
	} catch ( MalformedURLException ex ) {	  
	    System.out.println ( "Engine/<init>: Bad URL" );
	    System.exit(-1);
	}

	// Ask for some info from user.
	Query fr = new Query( scene, "Setup" );
	SceneInfo scinf = new SceneInfo();
	fr.init ( 250, 250, scinf );
	fr.show( );

	//Standard background colour. I want it black, but then 
	//MVM makes the info panels black as well.
	setBackground ( new Color( 192, 192, 192 ) );

	view.setBackground ( Color.black );
	view.setSize ( w.w, w.h );

	info.setBounds ( 500, 230, 200, 70 );
	help.setBounds ( 500, 300, 200, 200 );

	setLayout ( null );

	//Removes any previous stuff
	removeAll();

	add ( view );
	add ( buttons.pause );
	add ( buttons.track );
	add ( buttons.strafe );
	add ( buttons.rotate );
	add ( buttons.screw );
	add ( buttons.acc );
	add ( buttons.gravity );
	add ( info );
	add ( help );
	add ( buttons.help );
	add ( buttons.restart );
	
	/* Removed due to ugly artwork.
	   //I am just so good. This works!!!!!!!!!!!!!!!!!
	   Image cursor = getImage ( getCodeBase(), "cursor.gif" );
	   Toolkit toolkit = getToolkit();
	   setCursor ( toolkit.createCustomCursor( cursor, new Point ( 0, 0 ), "cursor" ) );
	*/

	setVisible ( true ); //Necessary function
	
	Part.toggleKin ( false ); //Need a clean start with the static vars.

	clock.start(); //Let's rock.
	framer.start();


	app.showStatus( "Eng/main: Program initiated" ); //Now tell the user.
	
    }
	
    /**
       This method redraw the whole applet, cascading the call down through the program hierarchy.
    */
    public void redraw()
    {
	repaint();
	view.redraw();
    }

    public String getAppletInfo()
    {
	return "Engine, the gravity simulator. By Daniel Armyr. (c)2001, all rights reserved.";
    }

    public void destroy()
    {
	//This returns errors. Strange.
	//clock.destroy(); 
	//framer.destroy();
    }

}









/**
* This little class deals with redrawing the applet, at appropriate intervals.
*/
public class Framer extends Thread
{
    private Engine engine; //A reference.
    private int framePeriod; //Time to wait.
  
  	/** 
 	* Creates a new Framer instance. 
 	* @param fp The time to wait between each frame.
 	* @param e The applet to redraw.
 	*/
    public Framer ( int fp, Engine e )
    {
		framePeriod = fp;
		engine = e;	
    }

    /** 
	* Does the actual calls to update the applet every few milliseconds
	*/
    public void run ()
    {
		while ( true ) {
		    try {
				Thread.sleep( framePeriod );
		    }
		    catch ( InterruptedException e ) {
			}
		    engine.redraw(); //Draw up next frame
		}
    }
}
/**
* This class is just a name. I think I use it in case an object tries to draw without having a proper graphics object. 
* Well, it does do some good, somewhere. No methods, no fields, not even a constructor.
*/
public class GraphicsException extends RuntimeException
{
    //Don't really do anything.
}
/**
* This class defines one particle's contribution to the total gravitational field. 
*/
public class Graviton
{ 
    /** The position of the current particle */	
    public Vector3 pos;
    /** The mass of the current particle */
    public double m;
    /** 
    * The reference of the current particle. Used to id the particle who created 
    * the field, and avoid some DivideByZero errors.
    */
    public Part id;
	
	/**
	* This constructor simply creates a new <code>Graviton</code>.
	* @param p The position of the particle.
	* @param mass The particles mass.
	* @param identity The reference to the current particle.	
	*/
    public Graviton ( Vector3 p, double mass, Part identity )
    {
	pos = p;
	m = mass;
	id = identity;
    }

}
/**
* This interface defines an object that has a velocity, an acceleration and can move.
*/
public interface Inertial extends Location
{
    /** 
  	* Tells the object to move a certain distance.
  	* @param dt The time the object should move through.
  	*/
    public void move ( int dt ); //Tells the object to move go to where it should be.
    /**
    * Sets the acceleration of the current object.
    * @param a The objects new acceleration
    */
    public void setAcc ( Vector3 a ); //Sets the current acceleration. Not final.
    /**
    * Sets the velocity of the current object.
    * @param v The objects new velocity
    */
    public void setVel ( Vector3 v ); //Sets current speed
    /** 
    * Tells the object to begin moving. All objects should begin deactivated. 
    * This assures no objects start running around until everything is ready.
    */
    public void activate( );
}
import java.awt.*;
/**
* This is a simple wrapper-class for the TextArea. The difference is that it defaults to non-editable, 
* and that is about it.
*/
public class Info extends TextArea
{
	/** Creates a new, non-editable TextArea object. */
    public Info( String p )
    {
	super ( p, 0, 0, 1 );
	setEditable ( false );
    }
    /** 
	* Tells the Info object to display a string of text. 
	* @param s The String to display.
	*/
    public void print ( String s )
    {
	setText ( s );
    }	    
}
/** A simple interface used by all objects for which a location is relevant */
public interface Location
{
    /** 
	* Get the location of the current object. 
	* @return The objects current position
	*/
    public Vector3 getPos();
}
/** 
* This class is just a name. Since gravity generally is a strictly positive occurrence, negative masses
* are considered an error and throw an exception.
*/
public class NegativeMassException extends RuntimeException
{
    //Doesn't really do anything.....
}
/**
* This is a camera that uses orthogonal projection. It is the simplest form and serves mostly as a debugging tool. 
* The images produced are quite boring. However, it is very stable and simple, and objects don't hide behind the 
* camera all the time.
*/

public class Orto extends Camera
{
   	/**   
     * Creates an instance of Orto. 
     * @param pos The initial position of the camera.
     * @param right A vector defining the right limit of the view-port  
     * @param up A vector defining the upper limit of the view-port 
    */
    public Orto ( Vector3 pos, Vector3 right, Vector3 up )
    {
    	/* 	Width and height define the area of the camera plane. They are 
     	 	independent of the size of the canvas to be drawn to. This allows 
     		quick resizing to the window.
    	*/
		super ( pos, right, up );
    }

    public void rot( double x, double y, double z )
    {
	right.rot ( x, y, z );
	up.rot ( x, y, z );
	//System.out.println ( "Camera/rot: " + x + " " + y + " " + z );
    }
  public Vector3 project ( Vector3 p3 )
  {

    // Return vector;
    Vector3 p = new Vector3();
      
    //Vector between camera centre and p3
    Vector3 PC = new Vector3 ( p3.x - pos.x,  
			       p3.y - pos.y,  
			       p3.z - pos.z );
      
    // Project point on camera plane
    p.x = right.dot ( PC );
    p.y = up.dot ( PC );
    p.z = PC.length();
      
    return p;
  }

    public boolean collDetect ( Vector3 sPoint, Vector3 oPoint, double rad )
    {
	return false;
    }    
}
import java.awt.color.*;
import java.awt.*;

/** 
 * This is the class for all objects that interact with the gravitational field in the simulation. 
 * They are graphically represented a spheres with a radius proportial to the cube root of the mass.
 * They further feature graphic displaying of acceleration and velocity. This is shown as two 
 * lines in the respective directions with lengths directly proportional to the relevant
 * kinematical quantity.
 */
public class Part extends Sphere implements Inertial
{
    private Vector3 v; //Velocity
    private Vector3 a; //Acceleration
    private long lTime;
    private boolean active = false;
    private double m; //Mass
    private static double G = .001; //Universal gravity constant
    private static double cutoff = 5;
    private boolean focus = false;
    private static boolean kin = false;
    private Color baseColor; //Deprecated
   
   	/** 
     * Creates a new particle. Newly created particles have no initial velocity, and are not affected by the 
     * gravitational field, although they themselves contribute. 
     * @param pos The initial position of the particle
     * @param mass The mass of the particle
     */
    public Part (  Vector3 pos, double mass )
    {
	super( pos, Math.pow( mass, .3 ), null ); //Density is 1.
	//Check that we don't have a negative mass
	if ( mass < 0 ) {
	    throw ( new NegativeMassException() );
	}
	//Set color depending on mass
	col = massColor ( mass );
	//We need a backup.
	baseColor = col; //Deprecated.

	v = new Vector3( 0, 0, 0 );
	a = new Vector3( 0, 0, 0 );
	m = mass;
    }  
    
    /**
     * Tells the particle to adjust it's acceleration to the current gravitational field. 
     * In effect this function tells the particle to start taking an active part in the simulation.
     */
    public void activate ( )
    {
	active = true;
    }

    public void frame ()
    {
	if ( focus ) {
	    g.setColor ( Color.white );
     	} else {
	    g.setColor ( col );
	}
	super.frame();
	/*
	  Draws a line with length and direction of the current acceleration. 
	  Should have a button for enabling and disabling.
	*/
	if ( kin ) { //Took away an == true
	    try {
		Vector3 p = cam.project ( pos );
		Vector3 acc = cam.project ( pos.add( a.mult( 100 ) ) );
		Vector3 vel = cam.project ( pos.add( v.mult( 10 ) ) );
		
		g.setColor( Color.white );
		drawLine ( p, acc );
		
		g.setColor ( Color.yellow );
		drawLine ( p, vel );
	    } catch ( NullPointerException e ) {
			System.out.println ( "Part/frame: Null pointer" );
	    }
	}
    }
   
    /**
     * This function tells the object to move through a distance matched by the time dt. 
     * In the particles case, this means adjusting the velocity by the acceleration, and them moving.
     * @param dt The time to move through.
     */
    public void move ( int dt )
    {
	if ( active ) { //Don't move objects that arn't mobile. Took away an == true
	    v = v.add ( a.mult( dt ) );
	    //System.out.println ( v.x + " " + v.y + " " + v.z + "\t" + a.x + " " + a.y + " " + a.z  );
	    pos = pos.add ( v.mult( dt ) );
	}
    }
   
   	/**
     * This function tells the particle to adjust it's acceleration in accordance to the current gravitational 
     * field. Only the acceleration is actually changed by calling the function. In order to actually move
     * the object, <code>move</code> must be called. However, if too objects are too close, they are merged together
     * by the throwing of a collision exception.
     * @param grav An array of gravitons that define the current gravitational field.
     * @exception CollisisonEvent If two objects are too close, they will be merged together 
     * into one larger particle. No more calculations will be performed on the current object 
     * in that frame.
     */
    public void fall ( Graviton[] grav ) throws CollisionEvent
    {
	Vector3 e = new Vector3();
	double f = 0;
	Vector3 force = new Vector3();
	/*
	  Loop through and calculate the gravitational field at the point 
	  where this particle is, ignoring the infinite gravity of the 
	  particle we are counting for.
	*/
	for ( int i = 0; i < grav.length; i++ ) {
	    if ( grav[i].id != this ) {
		//Get direction of force...
		e = grav[i].pos.sub( this.pos ); 
		if ( e.length() <= this.rad + grav[i].id.getRad() ) {
		    throw ( new CollisionEvent ( this, grav[i].id, i ) ); //Objects merge....
		    //e = new Vector3(); //To avoid dividebyzero error.
		} else {
		    f = G * grav[i].m * this.m /  //Newtons gravity.....
			this.pos.sub( grav[i].pos ).length();
		    e = e.unit();
		}
		force = force.add ( e.mult( f ) );
	    }
	}
	//Calculate acc...
	a = force.div ( this.m );

    }
    
    //Sets the current acceleration.
    public void setAcc ( Vector3 a )
    {
	this.a.cp ( a );
    } 
    
    public void setVel ( Vector3 v )
    {
	this.v.cp ( v );
    }  
    
    /** 
    * Generates a Graviton object. Used to inform the scene how 
    * this particle affects the current gravitational field.
    * @return The graviton describing the current object.
    */
    public Graviton getGrav()
    {
	return new Graviton ( new Vector3( pos ), m, this );
    }
    
    /**
    * Tells this object weather it has focus or not. Focus means that 
    * the mouse points to the current object. The particle's normal 
    * response should be to repaint itself in some other style or colour.
    * @param b Weather this object has focus or not.
    */
    public void setFocus ( boolean b )
    {
	focus = b;
    }
    
    /** Sets the Gravitational constant for all particles scene. */
    public static void setGrav ( double value )
    {
	G = value;
    }
    
    /** Toggles weather to show kinematical information graphically or not. */
    public static void toggleKin ()
    { 
	if ( kin ) //Took awayn an == true
	    kin = false;
	else
	    kin = true;
    }

    /**Sets the kinematics state. Used to make sure the proper state is set when program starts. */
    public static void toggleKin ( boolean state )
    {
	kin = state;
    }

	/** Returns a string with a short description of the current particle. For debugging. */    
    public String toString()
    {
	return "Mass: " + (float)m + "\nRadius: " + (float)rad + "\nSpeed: " + (float)v.length() + "\n";
	    
    }
    
    /** Returns the particles current velocity */
    public Vector3 getVel ()
    {
	return v;
    }
    
    /** Returns the particles current mass */
    public double getMass()
    {
	return m;
    }
    
    // Returns a colour depending on the colour of the entered object.
    private Color massColor ( double mass )
    {
	int[] color = { 150 + (int)(mass / 3), (int)(mass), 10 };
	for ( int i = 0; i < 3; i++ ) {	   
	    if ( color[i] > 255 )
		color[i] = 255;
	    if ( color[i] < 0 )
		color[i] = 0;
	}
	return new Color ( color[0], color[1], color[2] );
    }
}





/**
* This is the standard camera. It uses the common pinhole projection which it a quite good approximation 
* of most cameras under normal circumstances. The main benefit is that it is very quick, as 
* it doesn't use trigonometry.
*/
public class Perspec extends Camera
{
    /* inheritance
      public Vector3 pos; //Position vector of camera
      public Vector3 right; //Half the vector width of the camera
      public Vector3 up; //Half the vector height of the camera
      public Vector3 dir; //Unit direction of camera
      public Vector3 size; //Cameras clipping values
    */

    /** 
    * Creates a new pinhole camera. This constructor takes the same arguments as camera, but 
    * interprets them differently. The camera is seen as having a plane of size width*height set 
    * 1 unit in front the focus of all the rays. |vector| > 1 is generally unsuitable, 
    * although neither a physical nor programmable problem.
    */
    public Perspec ( Vector3 pos, Vector3 right, Vector3 up )
    {
		super ( pos, right, up );
    }

	/** 
 	* Projects a point in 3-space onto the view-plane. This function uses pinhole projection, 
 	* which is quick, and gives very good results if the FOV isn't too large.<BR>
 	* Make sure to check the super-class documentation for more details.
 	*/
    public Vector3 project ( Vector3 p3 )
    {
	//Make sure location is up to date. Yes!! This looks absolutely professional....
	//doTrack();

	// Return vector;
	Vector3 p = new Vector3();
      
	//Vector between camera centre and p3
	Vector3 PC = new Vector3 ( p3.x - pos.x,  
				   p3.y - pos.y,  
				   p3.z - pos.z );

	if ( dir.dot ( PC )  <= 0 ) {
	    p = null;
	} else {
	    //Do actual projecting
	    p.x = right.dot ( PC ) / dir.dot ( PC );
	    p.y = up.dot( PC ) / dir.dot ( PC );
	    p.z = PC.length();
	}
	//System.out.println ( "Per/project: Call finished." );
	return p;
    }
  
  	
    public boolean collDetect ( Vector3 sPoint, Vector3 oPoint, double rad )
    {
	//Fix point to rastered screen cordinates.

	//Calculate ray
	//1) initial point
	Vector3 p = pos;
	//2) direction vector
	Vector3 isect = new Vector3 ( sPoint.x/(2*size.x), sPoint.y/(2*size.y) );
	Vector3 u = dir;
	u = u.add ( right.mult ( -isect.x ) );
	u = u.add ( up.mult ( isect.y ) );
	u = u.unit();
	//Done....

	//Calculate particles distance from ray
	//1) Find vector from camera to particle
	Vector3 CP = oPoint.sub ( p );
	//2) Project onto u
	Vector3 proj = u.mult ( CP.dot ( u ) );
	//3) Find orthogonal vector from ray to point
	Vector3 orto = CP.sub ( proj );
	//4) Find length
	double dist = orto.length();
	//Done...

	//System.out.println ( "orto: " + orto.length() );


	//final check.
	if( dist < rad ) {
	    //System.out.println ( "Colission" );
	    return true;
	} else {
	    return false;
	}
    }
}



import java.awt.*;
import java.awt.color.*;

/**
* This class is the parent for all shapes. It includes some general methods for calculations that shapes 
* must do to be able to draw them selves.
*/
public abstract class Primitive implements Location
{
    /** Position of current object */
    protected Vector3 pos;
    /** The dimentions of the current screen. Should not be edited by hand. */ 
    protected static Vector3 screen; 
    /** Camera used to render the current object. */
    protected static Camera cam; 
    /** The current graphics object. Don't edit yourself. */
    protected static Graphics g;
    /** The current objects color. */
    protected Color col;
    
    /** 
    * An ambient light used for the shading.
    */
    protected Vector3 light = new Vector3 ( 1, 1, 1 );

    /** 
    * Creates a new primitive object.
    * @param pos The primitives location.
    * @param col The primitives initial color.
    */
    public Primitive ( Vector3 pos, Color col )
    {
	this.pos = new Vector3( pos );
	this.col = col;
    }

    /**
    * Draws the current Primitive in a window defined by win as seen from 
    * the camera cam. Each Primitive subclass needs to define their own version
    * of this method since it is a shape-unique method.
    */
    public abstract void frame ( );

    /**
    * These are frame specific informatia that need to be configred. 
    * They only need to be done once per frame for the whole scene, 
    * as it initializes the software-internal graphics system. 
    * @param camera Tells all objects what camera to render from.
    * @param win Information on the current viewport.
    */
    public static void initFrame ( Camera camera, WinDesc win )
    {
	screen = new Vector3 ( win.w, win.h);
	g = win.g;
	cam = camera;
    }

    public Vector3 getPos ()
    {
	return pos;
    }

    /** 
     * Rotates the object around the origin. Serves absoulutely no purpose in the 
     * gravitation simulation, but allows freedom of implementation.
     */    
    public void rot ( double x, double y, double z )
    {
	pos.rot ( x, y, z );
    }
    /** Moves the current object */
    public void trans ( double x, double y, double z )
    {
	
	pos.cp ( pos.add ( x, y, z ) );
    }

    /** Returns the screen cordinates of entered point on the viewplane. */
    protected Vector3 cord ( double x, double y )
    {
	return new Vector3 ( screen.x/2*( 1 + x / cam.size.x ) , screen.y/2*( 1 - y/cam.size.y ), 0);
    }
 
    /** Wrapper function for <code>Vector3 cord ( double x, double y )</code>. */
    protected Vector3 cord ( Vector3 p )
    {
	return cord ( p.x, p.y );
    }

    /** Draws a circle on the viewplane. The function automatically transforms to screen-cordinates. */
    protected void drawCircle ( double x, double y, double r, Color col )
    {
	Vector3 p = cord ( x, y );

	//g.setColor ( col );
	g.drawOval ( (int)(p.x - r/2), (int)(p.y - r/2), (int)(2*r), (int)(2*r) );
	
	//System.out.println ( "Prim/drawCirc: " + p.x + " " + p.y );

    }
    
    /** Draws a line on the viewplane. The function automatically transforms to screen-cordinates. */
    protected void drawLine( Vector3 p1, Vector3 p2 )
    {
	if ( p1 == null || p2 == null) {
	    /*
	      This simply means that the point is behind the camera. This is a
	      measure to make sure we get a single sided projection cone, 
	      and not a camera that can see in both directions.
	    */
	} else {
	    Vector3 a = cord( p1 );
	    Vector3 b = cord( p2 );
	    
	    //g.setColor ( col );
	    g.drawLine ( (int)a.x, (int)a.y, (int)b.x, (int)b.y );
	}
    }
    
    /** Draws a point on the viewplane. The function automatically transforms to screen-cordinates. */
    protected void drawPoint ( Vector3 p ) 
    {
	if ( p == null ) {
	    //Do nothing, point behind camera...
	} else {
	    Vector3 a = cord ( p );
	    //g.setColor ( col );
	    g.drawRect ( (int)a.x, (int)a.y, 1, 1 );
	}
    }

    /** 
	* Draws a filled triangle on the viewplane, scaling to 
	* screen-coordinates automatically. The function takes back-facing into account, and 
	* uses a flat-shading algorithm, which unfortunately seems to change the hue even if
	* only the brightness should change. This is due to a malfunction in the getHSVcolor() 
	* function.
	*/
    protected void doTri ( Vector3 p1, Vector3 p2, Vector3 p3, double s ) 
    //Draws a triangle, using curent camera, taking note of lights
    {
	//Project points
	Vector3 d1 = cam.project ( p1 );
	Vector3 d2 = cam.project ( p2 );
	Vector3 d3 = cam.project ( p3 );

	if ( d1 == null || d2 == null || d3 == null ) {
	    /*
	      This simply means that the point is behind the camera. This is a
	      measure to make sure we get a single sided projection cone, 
	      and not a camera that can see in both directions.
	    */
	} else {
	    Vector3 a = cord( d1 );
	    Vector3 b = cord( d2 );
	    Vector3 c = cord( d3 );
	    
 	    int x[] = { (int)a.x, (int)b.x, (int)c.x };
	    int y[] = { (int)a.y, (int)b.y, (int)c.y };

	    //Do we have a backface?
	    //1) Find cross product.
	    Vector3 v1 = a.sub ( b );
	    Vector3 v2 = b.sub ( c );
	    Vector3 n = v1.cross ( v2 );
	    //2) Is z-component negative?
	    if ( n.z < 0 ) {
		
		//Check if the current color is white. If it isn't, start shading.
		if ( g.getColor().equals ( Color.white ) ) {
		    //Set the color to white, and get drawing....
		    g.setColor ( Color.white );
		} else {
		    //Find normal
		    v1 = p2.sub ( p1 );
		    v2 = p3.sub ( p1 );	
		    n = v1.cross( v2 );
		    
		    //Find cos of angle between normal and some predefined vector Light.
		    double cos = n.dot ( light ) /  ( n.length() * light.length() );
		    		  
		    //Convert color to better format
		    float hsb[] = Color.RGBtoHSB ( col.getRed(), col.getGreen(), col.getBlue(), null );
		    
		    //Adjust brightness, cos e [-1,1] and adds some to loose the gloomy effect
		    hsb[1] -= cos / 2 + .5;

		    if ( hsb[1] < 0 )
			hsb[1] = 0;
		    if ( hsb[1] > 1 )
			hsb[1] = 1;
		    		    
		    //Extremely ugly
		    g.setColor ( Color.getHSBColor ( hsb[0], hsb[1], hsb[2] ) );
		}
		//Draw Triangle
		g.fillPolygon ( x, y, x.length );
	    }
	}
    }
}




  
import java.awt.*;
import java.awt.event.*;

/**
* This is a small frame that opens during the beginning of the program. It allows
* the entry of several options, of wich all have a recomended value pretyped.
* Fairly much a textbook thing....
*/
public class Query extends XFrame implements ActionListener
{
    TextField avMass = new TextField( "50" ); //Average Mass
    TextField galSize = new TextField( "200" ); //Galaxy Radius
    TextField nO = new TextField ( "100" ); //Number of planets
    CheckboxGroup galType = new CheckboxGroup(); 
    Checkbox galCyl = new Checkbox( "Planar", galType, true ); //Plane galaxy
    Checkbox galSphere = new Checkbox( "Spherical", galType, false ); //Round galaxy
    Button submit = new Button ( "Start" ); //The big red button...
    SceneInfo scinfo; //Info about how to build the scene
    Scene scene; //The scene itself

  	/** 
  	* Creates a Query object. 
  	* @param s The scene to affect.
  	* @param title The title of the Query object. Passed on to Frame.
  	*/
    public Query( Scene s, String title )
    {
		super( title );
		scene = s;
    }

	/**
	* Does the meat of the creation work. It may seem a bit redundant to have a separate method for this, but it
	* is an inheritance from the way XFrame is made. 
	* @param w The width of the window.
	* @param h The height of the param object.
	* @param scinf A structure to contain the info generated about the scene.
	*/
    public void init ( int w, int h, SceneInfo scinf )
    {
	scinfo = scinf; //Store a reference
	super.init( w, h ); //Get the windo running.
	setBackground ( new Color( 192, 192, 192 ) ); //A nice Win95-gray
	GridLayout grid = new GridLayout ( 6, 2 ); //Quick and dirty...
	setLayout ( grid ); 

	add ( new Label( "Average Mass" ) );
	add ( avMass );

	add ( new Label( "Galaxy Size" ) );
	add ( galSize );

	add ( new Label( "Number of particles" ) );
	add ( nO );

	add ( new Label( "Type of Galaxy" ) );
	add ( new Label( "" ) );

	add ( galCyl );
	add ( galSphere );

	add ( submit );
	submit.addActionListener( this );
	
    }
    
    /**
    * Kicks in when the user puches the submit button. This function parses 
    * and stores the data. Passes it to the scene and then commits
    * suicide.
    */
    public void actionPerformed( ActionEvent e )
    {
	if ( e.getSource() == submit ) { //Security check.
	    //Parse info.
	    scinfo.avMass = Integer.parseInt( avMass.getText() );
	    scinfo.galSize = Integer.parseInt( galSize.getText() );
	    scinfo.nO = Integer.parseInt( nO.getText() );
	    if ( galType.getSelectedCheckbox().getLabel().equals ( "Planar" ) ) { //Homemade parser
		scinfo.galType = SceneInfo.PLANAR;
	    } else {
		scinfo.galType = SceneInfo.SPHERICAL;
	    }
	    scene.init( scinfo ); //Pass info on.
	    this.dispose(); //Goodby cruel world.
	}
    }
}

/**
* This is the interface that defines a scene. It is completely generic, meaning anyone 
* can implement any scene with any math in it. The only speciffic function is the gravity 
* related one. However, it isn't worth the trouble to change it.
*/
public interface Scene 
{ 
    public void init ( SceneInfo scinf ); //Greates all dynamic objects.
    /** 
     * Tells the scene to draw itself. Scene should simply pass this on to idividual objects, 
     * after perhaps doing some housekeeping.
     */
    public void frame( WinDesc w ); //Draw the frame. 
    /** Tells the scene to update itself, meaning one step in the simulation has passed. */
    public void runFunc ( ); 
    /** Rotate the camera in local space. */
    
    public void camRot ( double x, double y, double z );    
    /** Roll the camera in local space */
    public void camRoll ( double a );
    /** Strafe camera in local space. */
    public void camStrafe ( double x, double y, double z ); 
    /** Ask camera if any object is at x and y on screen */
    public Primitive collDetect ( double x, double y ); 
    /** Sort all objects in scene depending on distance dfrom camera. Using brute force. Should use better sort... */
    public void camTrack( Location object ); 
    /** Adjust gravity in scene. */
    public void setGrav ( int value ); 
    /** Show acc or not */
    public void toggleKin ();  
    /** @deprecated Noone except scen should handle individual objects. */
    public Part getO( int n );
    /** @deprecated Noone except scen should handle individual objects. */ 
    public int getNO (); 
    /** @return The camera curerntly being used for rendering. */
    public Camera getCam();
    /** Prints out the curent status of the scene. */
    public void printStatus();
    /** Returns the object currently being tracked by the rendering camera */
    public Location getTrack();
}
/** A structure containing some info about how to build the scene. Used as a messanger between Query and Scene. */
public class SceneInfo 
{
    /** The number of particles */
    public int nO = 0;
    /* Their average mass */ 
    public double avMass = 0;
    /* Size of the area to spread particles over */
    public double galSize = 0;
    /* The type of galaxy to generate.*/
    public int galType = 0;
    
    /** A flat galaxy */
    public static int PLANAR = 0;
    /** A more round galaxy */
    public static int SPHERICAL = 1;
}



import java.math.*;
import java.awt.*;
import java.awt.color.*;
import java.util.*;

/**
This class only keeps track of registered primitives making sure that they are all drawn and moved.
It does no math. All math should be done by Primitive and it's children
However, it is also responsible for providing the objects with scene-global info.
This class only implements one camera at the time. Many can be defined, but this is strongly disrecommended


Warning: Collision-detection does not work. Planets are swallowed up and then dissapear. 
Solution: They got their mass as size. Hence out of screen.... ;) Stupid me.

New error: Collided objects do not move arount. They are drawn, but are static, even if they report both velocity and acceleration.
Horay. Long live debugging!!! How could I have guessed that the objects weren't activated....

I can't seem to get the machine to place out random elements. Indexoutofbounds in nO > 2
Fixed, but added O(n) searching of vector. Unnecesary.
*/

public class Solar implements Scene
{
    private Vector objects; //All dynamic particles
    private int nO; //number of dynamic particles. Deprecated.
    private Star[] stars; //Some stars
    
    //private Tripod tri; //And a cordinate system. Apparently confusing.
    private Camera camera; //A camera is nice
    private boolean depth = false; //Wireframe does not need depth-testing            
    private Part selected = null; //Nothing initially selected
    private Dummy dummy = new Dummy(); //A hook for the camera
    private double mouseStrafeScaleFactor = .5; //A nice value. used to strafe camera
    private double mouseRotateScaleFactor = .01; //Same here. used to rotate camera.
  
    /** Creates a new solar system. */
    public Solar () // SceneInfo scinfo )
    {
	
	//tri = new Tripod ( new Vector3 ( 0, 0, 0 ), 10 ); //Not for the final version. Confuses people
	
	camera = new Perspec ( new Vector3 (400, 0, 0 ), //New camera
			       new Vector3 ( 0, .5, 0 ),
			       new Vector3 ( 0, 0, .5 ) );
	
	//System.out.println ( "Size: " + objects.size() + "\n" + objects );	

	objects = new Vector(); //Start making objects

	//init ( scinfo );

	stars = new Star[500]; //Many stars
	
	for ( int i = 0; i < stars.length; i++ ) {
	    double t = Math.random()*100; //One angle
	    double p = Math.random()*100; //A second angle
	    stars[i] = new Star ( t, p, Double.MAX_VALUE, 10, Color.white ); //And initialize
	}
	camera.initTrack ( dummy ); //Follow that dummy!
    }

    public synchronized void init ( SceneInfo scinfo )
    {
	//position
	double x, y, z;
	
	for ( int i = 0; i < scinfo.nO; i++ ) { //Place them in one by one.
	    if ( scinfo.galType == SceneInfo.PLANAR ) {
		x = 0;
	    } else {
		x = (Math.random()*2-1)*scinfo.galSize;
	    }
	    y = (Math.random()*2-1)*scinfo.galSize;
	    z = (Math.random()*2-1)*scinfo.galSize;
	    
	    objects.addElement ( new Part ( new Vector3 ( x, y, z), Math.random()*2*scinfo.avMass ) );
	}
	
	for ( int i = 0; i < objects.size(); i++ ) { //Give them a velocity
	    Vector3 p = ((Part)objects.elementAt(i)).getPos();
	    ((Part)objects.elementAt(i)).setVel( p.cross( new Vector3(1, 0, 0 ) ).div( 100 ) );
	}
	
	
	for ( int i = 0; i < objects.size(); i++ ) { //Tell them to get moving. 
	    try {
		((Part)objects.elementAt(i)).activate();
	    } catch ( NullPointerException e ) {
		System.out.println ( "Scene/<init>: Object " + i + 
				     " not declared" );
		System.exit(-1);
	    }    
	}
    }


    public synchronized void frame( WinDesc w )
    {	
	Primitive.initFrame ( camera, w ); //File window information
	//tri.frame(); //Take out. Confuses people.
	camera.doTrack();
	
	if ( depth ) //If depth-testing is enabled
	    sortO();

	int i; //Helps debug with jdb.

	//Draw stars first, they tend to be behind.
	for ( i = 0; i < stars.length; i++ ) {
	    stars[i].frame();
	}	

	//Comes from runFunc. Better to have it here, but It looks like it doesn't work.... Fixed now....
	for ( i = 0; i < objects.size(); i++ ) {    
	    //Make sure objects know if they are selected
	    if ( objects.elementAt(i) == selected ) {
		((Part)objects.elementAt(i)).setFocus ( true );
	    } else {
		((Part)objects.elementAt(i)).setFocus ( false );
	    }
	    ((Part)objects.elementAt(i)).frame ( ); //And draw.
	} 	
    }

    public synchronized void runFunc ( )
    {
	Graviton grav[] = new Graviton [ objects.size() ]; //Make some space
	int i; //For jdb.

      	//Loop through to make gravity field
	for ( i = 0; i < objects.size(); i++ ) {
	    grav[i] = ((Part)objects.elementAt(i)).getGrav();
	}
	
	//Set the current acceleration for all objects. 
	for ( i = 0; i < objects.size(); i++ ) {
	    try {
			((Part)objects.elementAt(i)).fall( grav );
	    } catch ( CollisionEvent e ) {		
		//Start easy. Erase secondary object. 
		objects.removeElement( e.part2 ); //O(n)
		//Now try to replace first element with new element.
		objects.setElementAt( e.result, i );
		//Make sure we don't lose track. He He...
		if ( camera.getTrack() == e.part1 || camera.getTrack() == e.part2 ) {
		    camera.initTrack( e.result ); 
		}
		
	    }
	}
    
      
	//And finally, move the objects to their new positions.
	for ( i = 0; i < objects.size(); i++ ) {
	    ((Part)objects.elementAt(i)).move( 1 );
	}
	
	//Move camera to match tracked object's movements.
	camera.doTrack();
    }
    
    public void camRoll ( double a )
    {
	double s =  mouseRotateScaleFactor;
	camera.roll ( a*s );
    }
    public void camRot ( double x, double y, double z )
    {
	// 0, y, x
	//Warning. Orbits around some arbitrary, undefined point, but it looks good. Works perfectly now.
	double s =  mouseRotateScaleFactor;
	camera.orbit( -x*s, y*s, z*s );
    }

    public void camStrafe ( double x, double y, double z )
    {
	double s = mouseStrafeScaleFactor; //Too much writing.
	camera.strafe ( -x*s, y*s, -z*s ); //Take inverted screen into account
    }

    public Primitive collDetect ( double x, double y )
    {
	
	selected = null; //Start clean.
	for ( int i = 0; i < objects.size(); i++ ) { //Loop the loop
	    if ( camera.collDetect ( new Vector3 ( x, y ), ((Part)objects.elementAt(i)).pos,  ((Part)objects.elementAt(i)).rad ) ) { //Do the magic.
		selected = (Part)objects.elementAt(i); // Register as selected.
		return selected; //Return.
	    } 
	}
	
	return null;
    }

    public void camTrack( Location object )
    {                    
	if ( object == null ) { 
	    camera.initTrack ( dummy ); //Stand still
	} else {
	    camera.initTrack ( object ); //Follow and object.
	}
    }
    
    public void setGrav ( int value )
    {
	Part.setGrav ( (double)(100 - value)/50000 ); //Play God. Sets the universal gravitational constant.
    }
    
    public void toggleKin ()
    {
	Part.toggleKin(); //Pass on.
    }

    /* 
       This algorithm uses brute force. One that can take 
       advantage of the fact that the list is usually well
       -sorted would really help. Merge sort has been recommended. 
       Ask Peter Modin.
    */
	private void sortO ( ) 
    {
	//Bubble sort routine. Hopefully obsolete
	Object temp;
	boolean swap;
	for ( int i = 0; i < objects.size() - 1; i++) {
	    swap = false;
	    for ( int j = 0; j < objects.size() - 1; j++) {
		//find distances
		double dist1 = camera.getPos().sub( ((Part)objects.elementAt(j)).getPos() ).length();
		double dist2 = camera.getPos().sub( ((Part)objects.elementAt(j+1)).getPos() ).length();
		if ( dist1 < dist2 ) {
		    //Swap places
		    temp = objects.elementAt(j);;
		    objects.insertElementAt( objects.elementAt(j+1), j );
		    objects.insertElementAt( temp, j+1 );
		    swap = true;
		}
	    }
	    if ( !swap )
		break;
	}
	
    }

    public Camera getCam()
    {
	return camera; 
    }

    public Part getO( int n )
    {
	System.out.println( "Scene/getO: Deprecated" );
	return (Part)objects.elementAt(n);
    }
    public int getNO () 
    {
	System.out.println( "Scene/getNO: Deprecated" );
	return objects.size();;
    }
    public void printStatus()
    {
	System.out.println ( objects );
    }
    public Location getTrack()
    {
	return camera.getTrack();
    }

}










import java.awt.*;
import java.math.*;

public class Sphere extends Primitive {

    /* 	Inherited
	protected Vector3 pos; //Position of current 
	protected static Vector3 screen; //Should only be used by frame();
	protected static Camera cam; //Camera used to render the current object.
	protected static Graphics g; //The current graphics object. Don't edit yourself.
	protected Color col;
	protected Vector3 light = new Vector3 ( 1, 1, 1 );
    */
	
	/** The current sphere's radius */
    protected double rad;

	/** 
    * Create a new sphere.
    * @param pos The current sphere's position.
    * @param size The current sphere's radius.
    * @param color The current sphere's color.
    */    
    public Sphere ( Vector3 pos, double size, Color color )
    {
	super( pos, color );
	rad = size;
	col = color;
    }
 	
 	/**	Tells the sphere to draw itself. */
    public void frame ( )
    {
	Vector3 point = null; 
	try {
	    point = cam.project ( pos );
	} catch ( NullPointerException e ) {
	    System.out.println ( "Sphere/frame: Null Pointer I" );
	}

	if ( point == null ) {
	    //System.out.println ( "Sphere/frame: Point is behind camera" );
	} else {
	    try {
		//drawOcta ( cam, rad );
		//Implemented to alpha level, but requitres alot of work to be publishable
		//Actually, all it needs is back-facing. Backfacing fixed, but shading gives too much green
		//Has now reached pre-beta. If I can do my own HSV algorithm, it will be implemented. However, 
		//pre-beta it is. Gives a touch of seriosity.
		fillOcta( cam, rad );	    
	    }
	    catch ( NullPointerException e ) {
		System.out.println ( "Sphere/frame: Null pointer II" );
	    }

	}

    }
    
    /** Draws an octahedron using the given camera to the given viewport. */
    protected void drawOcta( Camera cam, double s )
    {
	try {
	    //g.setColor ( col );
	
	    Vector3 p1 = cam.project ( pos.x, pos.y, pos.z + s );
	    Vector3 p2 = cam.project ( pos.x - s, pos.y, pos.z );
	    Vector3 p3 = cam.project ( pos.x, pos.y - s, pos.z );
	    Vector3 p4 = cam.project ( pos.x+s, pos.y, pos.z );
	    Vector3 p5 = cam.project ( pos.x, pos.y+s, pos.z );
	    Vector3 p6 = cam.project ( pos.x, pos.y, pos.z-s );
	    

	    if  ( p1 == null ||  p2 == null ||  p3 == null ||  p4 == null ||  p5 == null ||  p6 == null ) {
	    	//System.out.println ( "Points behind camera" );
		/*
		  If a point of the tetra is behind the camera, don't draw 
		  it al all. This eliminates the possibilty od a sky sphere, 
		  but it is alot faster. THe alternative is to introduce 
		  face-drawing, and then clip each individual face, 
		  if the SPARCS are fast enough. No need. Stars do the job.
		*/
	    } else {
		
		drawLine ( p1, p2 );
		drawLine ( p1, p3 );
		drawLine ( p1, p4 );
		drawLine ( p1, p5 );

		drawLine ( p2, p3 );
		drawLine ( p3, p4 );
		drawLine ( p4, p5 );
		drawLine ( p5, p2 );

		drawLine ( p6, p2 );
		drawLine ( p6, p3 );
		drawLine ( p6, p4 );
		drawLine ( p6, p5 );
	    }
	} 
	catch ( NullPointerException e ) {
	    //System.out.println ( "Sphere/drawOcta: Null Pointer" );
	}
    }

    /** 
     * Draws a filled octahedron, using flat shading and the given camera to the given viewport. 
     * @see Primitive#doTri( Vector3, Vector3, Vector3, double )
     */ 
    protected void fillOcta( Camera cam, double s )
    {
	try {
	    Vector3 p1 = new Vector3 ( pos.x, pos.y, pos.z + s );
	    Vector3 p2 = new Vector3 ( pos.x - s, pos.y, pos.z );
	    Vector3 p3 = new Vector3 ( pos.x, pos.y - s, pos.z );
	    Vector3 p4 = new Vector3 ( pos.x + s, pos.y, pos.z );
	    Vector3 p5 = new Vector3 ( pos.x, pos.y + s, pos.z );
	    Vector3 p6 = new Vector3 ( pos.x, pos.y, pos.z - s );
	    
	    
	    doTri ( p1, p2, p3, s );
	    doTri ( p1, p3, p4, s );
	    doTri ( p1, p4, p5, s );
	    doTri ( p1, p5, p2, s );
	    
	    
	    doTri ( p6, p3, p2, s );
	    doTri ( p6, p4, p3, s );
	    doTri ( p6, p5, p4, s);	    
	    doTri ( p6, p2, p5, s );
	    
	} 
	catch ( NullPointerException e ) {
	    //System.out.println ( "Sphere/drawOcta: Null Pointer" );
	}
    } 
    
    /** Return the spheres radius */
    public double getRad()
    {
	return rad;
    }
}



    
import java.awt.*;

/**
* Defines a star. A star is a Sphere that only displays as a single dot no matter the distance. 
* Used to maintain orientation in the sometimes caotic rotations of the camera.
*/
public class Star extends Sphere
{
    /** Creates a new star. */
    public Star ( double theta, double phi, double r, int size, Color color )
    {
	super ( new Vector3 ( r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi) ), size, color );
    }
    
    
    public void frame ( )
    {
	Vector3 point = null; 
	try {
	    point = cam.project ( pos );
	} catch ( NullPointerException e ) {
	    System.out.println ( "Tripod/frame: Null Pointer" );
	}
	if ( point != null ) {
	    g.setColor ( col );
	    drawPoint ( point );
	}		
    }
}
import java.awt.*;

/** 
* Draws a fix cordinate system at the origin. I used in in the begining to 
* maintain my orientation before the stars. Now obsolete, as it seems to confuse the
* users. However, if movement seems erratic, the cordinate system is a nice and handy
* reference point in debugging.
*/
public class Tripod extends Primitive
{
    private int s;

  	/** Creates a new Tripod. */
    public Tripod ( Vector3 pos, int size )
    {
	super( pos, null );
	s = size;
    }
    
    /**  Tells the Tripod to redraw itself. */
    public void frame ( )
    {
		Vector3 point = null; 
		try {
		    point = cam.project ( pos );
		} catch ( NullPointerException e ) {
		    System.out.println ( "Tripod/frame: Null Pointer" );
		}
	
		if ( point == null ) {
		    //Point is behind camera
		} else {
		    Vector3 O = cam.project ( pos );
		    Vector3 p1 = cam.project ( pos.add( new Vector3 ( 1, 0, 0 ) ) );
		    Vector3 p2 = cam.project ( pos.add( new Vector3 ( 0, 1, 0 ) ) );
		    Vector3 p3 = cam.project ( pos.add( new Vector3 ( 0, 0, 1 ) ) );
	
		    try {
			    	
				g.setColor ( Color.red );
				drawLine( O, p1 );
		
				g.setColor ( Color.green );
				drawLine( O, p2 );
		
				g.setColor ( Color.blue );
				drawLine( O, p3 );
				
		    } catch ( NullPointerException e ) {
				if ( g == null ) {
				    throw new GraphicsException();
				} else {
			    	System.out.println ( "Tripod/frame: Unknown Null pointer" );
				}
		    }
		}
    }
}
/** 
* A 3-space vector. Includes all the vector math necessary for the physics and graphics. 
* In reality the core of the whole program.
*/
public class Vector3
{   
	/** The cordinates of the vector */
	public double x, y, z;
    
    /** Creates a new vector */
    public Vector3 ( double x, double y, double z ) 
    {
		this.x = x;
		this.y = y;
		this.z = z;
    }
    
    /** Creates a new vector */
    public Vector3 ()
    {
		this ( 0, 0, 0 );
    }                          
    
    /** Creates a new vector */
    public Vector3 ( Vector3 v )
    {
		this( v.x, v.y, v.z );
    }
    
    /** Creates a new vector with only x and y defined. */
    public Vector3 ( double x, double y )
    {
    	this( x, y, 0 );
    }

	/** Copies the argument into the current vector. */
    public void cp( Vector3 p )
    {
	x = p.x;
	y = p.y;
	z = p.z;
    }

	/** Returns the sum of this vector and the argument. */
    public Vector3 add ( Vector3 v )
    {
		return new Vector3 ( this.x + v.x, this.y+v.y, this.z+v.z );
    }
    
    /** Returns the difference between this vector and the argument. */
    public Vector3 sub ( Vector3 v )
    {
	return new Vector3 ( this.x - v.x, this.y - v.y, this.z - v.z );
    }

    /** Wrapper function for <code>Vector3 add ( Vector3 v )</code>. */ 
    public Vector3 add ( double x, double y, double z )
    {
		return this.add( new Vector3 ( x, y, z ) );
    }
    
    /** Returns the product of the current vector and the scalar argument. */
    public Vector3 mult ( double x )
    {
	return new Vector3 ( this.x*x, this.y*x, this.z*x );
    }

	/** Returns the quotient between the current vector and the scalar argument. */
    public Vector3 div ( double x )
    {
	return new Vector3 ( this.x/x, this.y/x, this.z/x );
    }

	/** Returns the Euklidian scalar product between this vector and the argument. */
    public double dot ( Vector3 p )
    {
	return x*p.x + y*p.y + z*p.z;
    }

	/** Returns the vector cross product bewteen this vector and the argument */
    public Vector3 cross ( Vector3 p )
    {
	return new Vector3 ( this.y*p.z - this.z*p.y, 
			     this.z*p.x - this.x*p.z,
			     this.x*p.y - this.y*p.x );
    
    }

	/** Returns the Euklidian length of the current vector. */
    public double length ()
    {
	return Math.sqrt ( x*x + y*y + z*z );
    }

    /** Returns the unit direction of this vector. */
    public Vector3 unit()
    {
	return new Vector3 ( x/length(), y/length(), z/length() );
    }

    /** Rotate this vector in world space */
    public void rot ( double x, double y, double z )
    {
	rotX ( x );
	rotY ( y );	
	rotZ ( z );
    }

    /** Return a string with the elements of the current vector. */
    public String toString ()
    {
	return x + " " + y + " " + z;
    }
    
    // Rotates this vector around the X-axis.
    private void rotX ( double a )
    {
	double xt = x;
	double yt = y*Math.cos(a) - z*Math.sin(a); 
	double zt = y*Math.sin(a) + z*Math.cos(a);
	x=xt;
	y=yt;
	z=zt;
    } 
    
    // Rotates this vector around the Y-axis. 
    private void rotY ( double a )
    {
	double xt = x*Math.cos(a) + z*Math.sin(a);
	double yt = y;
	double zt = -x*Math.sin(a) + z*Math.cos(a);
	x=xt;
	y=yt;
	z=zt;

    } 
    
    /** Rotates this vector around the Z-axis. */    
    private void rotZ ( double a )
    {
	double xt = x*Math.cos(a) - y*Math.sin(a);
	double yt = x*Math.sin(a) + y*Math.cos(a);
	double zt = z;
	x=xt;
	y=yt;
	z=zt;

    }

	/** 
	* Rotates this vector around an arbitratry vector. <BR>
	* The matrix used to rotate is copied directly from Elementary Linear Algebra. 
	* @param a The ammount to rotate.
	* @param u The vector to rotate around. Should be a unit vector. 
	*/
    public void rotA ( double a, Vector3 u )
    {
	//Calculate transformation matrix.
	double v[][] =
	{
	    {
		u.x*u.x*(1-cos(a)) +     cos(a), 
		u.x*u.y*(1-cos(a)) - u.z*sin(a),  
		u.x*u.z*(1-cos(a)) + u.y*sin(a)
	    },
	    {
		u.x*u.y*(1-cos(a)) + u.z*sin(a),
		u.y*u.y*(1-cos(a)) +     cos(a),
		u.y*u.z*(1-cos(a)) - u.x*sin(a)
	    },
	    {
		u.x*u.z*(1-cos(a)) - u.y*sin(a),
		u.y*u.z*(1-cos(a)) + u.x*sin(a),
		u.z*u.z*(1-cos(a)) +     cos(a)
	    }
	};
 
	//Apply
	double xt = v[0][0]*x + v[0][1]*y + v[0][2]*z;  
	double yt = v[1][0]*x + v[1][1]*y + v[1][2]*z;  
	double zt = v[2][0]*x + v[2][1]*y + v[2][2]*z;  

	//Implement
	x = xt;
	y = yt;	
	z = zt;


    }
    //A wrapper meahod.
    private double cos( double x )
    {
	return Math.cos( x );
    }   
    
    //A wrapper meathod
    private double sin( double x )
    {
	return Math.sin( x );
    }
}



import java.awt.*;
import java.awt.event.*;

/** 
* This class defines the viewport. It indirectly handles the redrawing of the scene, and such things. 
* This implementation uses a back buffer to make the animation move more smoothly.
*/
public class View extends Canvas implements MouseMotionListener, MouseListener
{
    //References.
    private Scene scene;
    private WinDesc win;
    private Info info; 

    private Image buffer; //Back buffer
    private Graphics gBuffer; //Back buffers drawing tools
    private String mouseMode; //How to interprate mouse input.
    private Vector3 lMouse; //The last known position fo the mouse.
  
   	/** 
	* Creates a new viewport.
	* @param s The scene to draw to screen.
	* @param w The size of the viewport.
	* @param b The back buffer.
	* @param i The textarea to write status info to.
	*/  
    public View ( Scene s, WinDesc w, Image b, Info i )
    {
	lMouse = new Vector3();
	
	setBackground ( Color.black ); //Standard background color
	scene = s;
	win = w;
	buffer = b;
	info = i;
	
	try {
	    gBuffer = buffer.getGraphics(); //Enable drawing on back buffer
	} catch ( Exception e ) {
	    System.out.println ( "View/<init>: Null error in gBuffer" );
	}
	addMouseListener ( this );
	addMouseMotionListener ( this );
    }
    
    /** Tells the view object how to interprate mouse events. */
    public void setMouseMode ( String mode ) 
    {
	mouseMode = mode;
    }
    
    /** Returns the current mouse listening mode. */
    public String getMouseMode( )
    {
	return mouseMode;
    }
    
    /** Tells the component to redraw itself. Used to cascade the repaint message through the program. */
    public void redraw ()
    {
	//Update info in the view window.
	try {
	    info.print ( scene.getTrack().toString() );
	} catch ( NullPointerException e ) {
	    // No problem, things aren't allways selected
	}
	
    	repaint( );
    }
    
    /** Do all the double-buffering things. */
    public void update ( Graphics g )
    {	    
	//Double buffer stuff.
	gBuffer.setColor( getBackground() ); //Set the background color
	gBuffer.fillRect ( 0, 0, getSize().width, getSize().height ); //Blit black to the back buffer
	gBuffer.setColor ( getForeground() ); //Restore foreground color
	paint ( g ); //Paint new image
    }
    
    /** Draw the viewport */
    public void paint ( Graphics g )
    {   
	win.setG ( gBuffer ); //Register the curernt graphics object.
	scene.frame ( win ); //File the window information
	
	try {
	    g.drawImage ( buffer, 0, 0, this ); //Swap buffers
	}
	catch ( NullPointerException e ) {
	    System.out.println ( "BFrame/paint: Null pointer." );
	}
	
    }                    
    
    public void mousePressed( MouseEvent e )
    {
	if ( mouseMode.equals ( "Track" )) {
	    
	    double x = (double)( win.w/2 - e.getX() )/win.w; //Translate from screen to viewplane
	    double y = (double)( win.h/2 - e.getY() )/win.h; // - " -
	    Location object = scene.collDetect ( x, y ); //Is there something there?
	    scene.camTrack ( object ); //Track that object, may be null.
	    if ( object != null ) 
		info.print ( object.toString() ); //Show some stats.
	} else {
	    lMouse = new Vector3 ( e.getX(), e.getY() ); //File mouse pos.
	}
    }
    public void mouseReleased( MouseEvent e )
    {
    }
    public void mouseClicked( MouseEvent e )
    {
    }
    public void mouseEntered( MouseEvent e )
    {
    }
    public void mouseExited( MouseEvent e )
    {
    }
    public void mouseMoved( MouseEvent e )
    {
	double x = (double)( win.w/2 - e.getX() )/win.w; //Translate from screen to viewplane
	double y = (double)( win.h/2 - e.getY() )/win.h;
	//System.out.println ( "View/mMove: " + x + " " + y );
        scene.collDetect ( x, y ); //Is there something there?

    }
    public void mouseDragged( MouseEvent e )
    {
	//Move the camera according to the current move.
	if ( mouseMode.equals ( "Strafe" )) {
	    scene.camStrafe ( e.getX() - lMouse.x, e.getY() - lMouse.y, 0 );
 	} else if ( mouseMode.equals ( "Rotate" )) {
	    scene.camRot ( 0, e.getY() - lMouse.y, e.getX() - lMouse.x );
	} else if ( mouseMode.equals ( "Screw" )) {
	    scene.camRoll( e.getX() - lMouse.x );
	    scene.camStrafe ( 0, 0, e.getY() - lMouse.y );
	}
	lMouse = new Vector3 ( e.getX(), e.getY() ); //Register last mouse pos.
    }
}
		











import java.awt.*;

/** This class contains info about the current window. Allows objects to draw themselves. */
public class WinDesc 
{
	/** The graphics object used to draw with */
    public Graphics g;
	/** The width of the viewport */
    public int w;                
    /** The height of the viewport */           
    public int h;

	/** Create a new Windesc object.
    * @param width The wieport width.
    * @param height The viewport height.
    * @param gr The current graphics object.
    */
    public WinDesc ( int width, int height, Graphics gr )
    {
	g = gr;
	w = width;
	h = height;
    } 
    
    /** Diet version. Used if no graphics object is available, for example during initialization. */
    public WinDesc ( int width, int height )
    {
	w = width;
	h = height;
    }       
    
    /** Sets the current graphics object. */
    public void setG ( Graphics gr )
    {
	g = gr;
    }
}
import java.awt.*;
import java.awt.event.*;

/**
* This class is taken straight from the Java Direct book. It is a simple Frame with the
* exceptption that it can be closed properly. 
*/
public class XFrame extends Frame  
{
    /** 
    * Creates an instance of XFrame
    * @param title The title of the window to be created.
    */
    public XFrame( String title ) 
    {
	super ( title );
	addWindowListener ( closeCheck ); //In case the user wants to kill the window
    } 
    
    /**
    * Tells the XFrame to prepare for action. This method contains all cosmetics as well as the actual 
    * showing of the window. It is necessary to separate it from the constructor in order to make inheritance 
    * reasonably simple.
    * @param width The window's width.
    * @param height The window's height.
    */
    public void init ( int width, int height ) //Makes a window
    {
	setResizable ( false ); //If you want fixed-size windows
	setBackground ( Color.black ); //Standard background color
	setBounds ( 10, 10, width, height ); //define extents of window

	//show(); Show the window. Should be called last.
	//setVisible ( true ); //Necessary function
                                                                               
    }
    
    private WindowAdapter closeCheck = new WindowAdapter() {
	    public void windowClosing ( WindowEvent e ) { 
		dispose();
		//System.exit(0);
		//System.out.println ( "XFrame: Window closed..." );
	    }
	    public void windowMoved( WindowEvent e ) {
		//System.out.println ( "XFrame/windowMoved" );
	    }
	}; 
	
}
